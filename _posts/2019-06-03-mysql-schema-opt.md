---
layout: post
title: "《高性能MySQL》: Mysql Schema"
tags: 
- note
- reading
- db
---

# 选择优化的数据类型
- 选择的原则
    - 更小的通常更好，但是不要低估了数据的使用范围
    - 简单就好
        - 整型比字符操作代价更低（字符集的排序和校对很复杂）
        - 使用mysql内建的类型而不是字符串来存储时间
        - 用整数来存储IP

    - 尽量避免NULL
        - NULL列很难优化，索引，索引统计和值比较都很复杂
        - NULL列会使用更多的空间
        - 当可为NULL的列被索引时，每个索引需要记录一个额外的字节，MyISAM还可能导致索引从固定大小的索引变成可变大小的索引
        - 如果列要建索引，尽量不用使用NULL值
        - Innodb使用单独的bit来存储NULL值
- 数据类型
    - 整数类型
        - 类型
        TINYINT(8), SMALLINT(16), MEDIUMINT(24), INT(32), BIGINT(64)
        - 属性
            - 可选的UNSIGNED属性 TINYINT UNSIGNED
            - 陷阱
            整数运算一般使用64位的整数
            mysql可以为整数指定宽度，int(11)，但是不会限制整数的合法值，只是规定了一些交互工具显示的个数，对于存储和计算来说都是一样的

    - 实数类型
        - 类型
        FLOAT/DOUBLE/DECIMAL
        - 陷阱
            - 只在需要很精确的数据的时候才使用decimal
            - 可以使用bigint来存decimal的数字，通过乘以对应的倍数来实现，这样效率好而且避免了不精确的问题

    - 字符串类型
        1. 类型
            - VARCHAR/CHAR
            - BINARY/VARBINARY
            - BLOG(TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LONGBLOB)/TEXT(同样前缀)
            
        2. 细节
            - varchar
                1. 存储空间占用较少，因为是定长的。需要额外的字节来存储元信息；
                2. 如果update频繁，会导致片段分裂，页分裂
                3. 下面情况使用varchar
                    - 字符串的列的最大长度比平均的长度大很多
                    - 列的更新更少，所以碎片不是问题
                    - 使用了像utf-8这样的字符集，每个字符都使用不同的字节数进行存储
                4. 老版本的mysql会剔除末尾空格
                5. innodb会把很长的字符串转成blob存储
                6. 慷慨是不明智的，只分配自己需要的空间，MySQL会分配定长的内存块来存字符，更长的字符但是空闲会导致排序和其他操作效率降低
            - char
                1. 根据定义的长度分配足够的空间，末尾空格会被剔除
                2. 适合存密码之类的定长字符，不容易碎片
                3. binary/varbinary存储字节码而不是字符
            - blob/text
                1. 一个是二进制一个是字符串
                2. 排序只能排序一小部分(`ORDER BY SUBSTRING(col, len)`)
                3. 索引只能索引固定长度不能全部
                4. 磁盘临时表和排序
                    blob和text不被memory引擎支持，如果大量的需要排序的情况就只能使用临时磁盘表，但是可以使用substring来转成字符串使用内存表
                    如果explain执行计划的extra列包含 using temporary则说明查询使用了临时表
            - ENUM替代字符串
                1. enum实际存储成了整数
                2. 枚举字段是按照内部的整数而不是定义的字符串来排序的
                3. 避免varchar和enum相关联
                4. 在查找表的时候采用整数主键而避免采用基于字符串的值进行关联
    - 日期和时间类型
        1. DATETIME/TIMESTAMP
        2. datetime
            - 8字节存储
            - 范围从0000-9999年
            - 精度为秒
        3. timestamp
            - 时间戳
            - 1970 - 2038
            - 4字节存储
            - 时间戳和存储的时区密切相关
            - 如果插入的时候没有指定第一个timestamp的值服务器会默认给当前时间
            - not null
            - 插入一行记录的时候也会自动更新第一个timestamp的值
        4. 如果需要存储比s更精细的时间戳可以使用BIGINT或者DOUBLE存储
        位数据类型
    - BIT
        - BIT是字符串类型而不是数字类型
        - 检索BIT将会得到一个字符码对应的字符串
        - 如果想在一个BIT中存储true/false最好使用char(0)
        - MYISAM打包所有的BIT列，innodb则使用的是最小的整数，所以还是不能节约空间
    - SET
        - find_in_set() field() 函数
        - 可以有效的节约空间
        - 但是扩展需要alter table
        - 无法使用索引查找
        - 可以使用整数列来包装一系列的位

# 选择标识符
- 整数类型通常是标识符最好的选择，很快而且可以自增；
- ENUM SET对于标识符很糟糕
- 字符串类型应该避免使用，很消耗空间而且比数字类型慢，myisam还是压缩字符导致很慢
- 避免使用完全随机的字符串，这些函数生成的新值在很大的空间内，会导致页分裂，聚簇索引碎片，磁盘随机访问，select慢因为逻辑上相邻的行结果在磁盘和内存的不同位置。局部访问性原理失效
- 当心自动生成的scheme

# 特殊数据类型

- 使用无符号整数存IP 然后使用INET_ATON INET_NTOA来转化

# 常见陷阱

- 太多的列（数千个字段会导致转换的代价非常的高）
- 太多的关联
    最多可以关联61各表
    建议在12个表以内做关联

- 过分使用枚举
- 区分枚举和集合
- 尽量避免使用NULL但是该用还是要用（mysql会在索引中存储NULL值）

# 范式化的优点和缺点

- 范式化的更新操作通常比反范式化要快
- 当数据较好的范式化时就只有很少或者没有重复数据，所示一需要修改很少的数据
- 范式化的表通常更小，可以放到内存里，所以执行操作会快
- 很少有多余的数据意味着更少需要group或者distinct
- 但是需要关联，反范式化可以避免关联最大限度的使用顺序IO

# 缓存和汇总表

- 可以加快性能
- 实时维护和定期维护
- 影子表切换原数据和影子数据加快数据重建 先建设一张空的表然后填充数据然后对调两个表
- 物化视图- flexviews
- 计数器表的优化
    - 单纯的使用一个计数器会导致锁定
    - 可以重复插入很多行，更新的时候随机选择一行更新，聚合的时候汇总所有的行
    - 如果需要每个日期一个计数可以加字段然后定期汇总字段减少行的使用

- 代价： 增加读写的开发难度，需要维护额外的数据，写更慢了

# 加快alter table的速度

- facebook - online schema change
- open toolkit
- percona toolkit
- fixviews - CDC工具（捕获服务器的二进制日志）
- 主库备库切换，备库先执行修改操作，然后切换
- 影子拷贝 通过重命名和删表操作交换两个表
- 修改frm文件，先锁定表，然后建设一个需要的字段的表，然后替换frm文件，然后释放锁定
- 先关闭索引然后载入大量数据然后重新打开索引