---
layout: post
title: "《高性能MySQL》: 可扩展的MySql"
tags: 
- note
- reading
- db
---

可扩展性

- 定义： 当增加资源以处理负载和增加容量时系统能够获得的投资产出率

- USL可扩展性定律（线性扩展的偏差可以通过两个因素来建立模型）

    1. 无法并行执行的一部分工作 - Amdahl定律

    2. 需要交互的另外一部分工作 - 内部节点和进程间通信+amdahl定律

- 约束理论

    通过减少以来时间和统计变化来改进系统的吞吐量和性能
扩展mysql

1. 规划可扩展性 - 在项目开始的时候就预先规划容量

    - 应用的功能完成了多少

    - 预期的最大负载是多少

    - 如果以来系统的每个部分来分担负载那么失效的情况如何处理，是否需要预留容量

2. 为扩展赢得时间 - 可以推迟具体的扩展计划的方式

    - 优化性能 - 建立索引或者优化查询等

    - 购买性能更好的硬件

3. 向上扩展/垂直扩展 - 购买更好的性能更强悍的机器

4. 向外扩展/水平扩展 - 将任务分配到多台机器上

    - 复制拆分和数据分片

    - mysql节点的可能性

        1. 一个主主复制双机结构，拥有一个主动和一个被动服务器

        2. 一个主库和多个备库

        3. 一个主动服务器并使用块复制设备(DRBD)作为备用服务器

        4. 一个基于存储区域网络(SAN)的集群

    - 按功能划分

        - 不同的功能划分到不到的实例上或者单个实例的不同库对应不同的功能不做关联

        - 单个功能的单个实例还是有性能瓶颈

    - 数据分片

        - 数据分割成多片存在不同的节点

        - 过程： 复制分担读查询 -> 按功能拆分到不同实例 -> 单一功能的数据分片

        - 需要数据抽象层

        - 如果不用分尽量部分，通过优化的方式来完成

        - 选择分区键

            1. 分区键决定了在哪里存和哪里找数据

            2. 尽量减少重要且频繁查询的数据的分片

            3. 使用实体关系图来分片，找到关键节点

            4. 尽可能选择那些能够避免跨分片查询的

            5. 让分片尽可能小和公平

        - 多个分区键（需要冗余存储）

        - 跨分片查询

            1. 使用中间件来查询

            2. 使用汇总表和缓存冗余保存查询

            3. 只能应用来检查一致性

            4. 使用定期执行的任务来检查一致性清除数据等

        - 分配数据分片和节点

            1. 分片和节点不是一对一的关系

            2. 保持分片小尽量一个节点可以存多个分片

            3. 小片有利于分片的平衡和转移

            4. 大小是能够在5-10分钟能提供日常的维护工作的程度，太小的话会引发其他问题

        - 在节点上部署分片

            - 每个分片使用单一数据库而且库名相同

            - 讲过个分片的表放到一个数据库中，每个表明上包含分片号

            - 为每个分片使用一个数据库，并在数据库中包含所有应用需要的表，在数据库名中包含分片号，但是表名没有分片号

            - 每个分片使用一个数据库，并在数据库名和表明中包含分片号

            - 在每个节点是运行多个mysql实例，每个实例上一个或者多个分片

        - 固定分配

            - 实现简单

            - 如果分片很大数量不多很难均衡不能分片间的负载

            - 固定分片的方式无法自定义数据放到哪个分片上，如果分片间负载不均衡会有问题 - 所以分片尽可能小

            - 修改分片策略通常比较困难

        - 动态分配

            - 使用一个额外的表来存储具体的数据行和shardid的对应关系

            - 对数据存储位置精确控制

            - 灵活，减少跨分片查询

        - 混合动态和固定分配

        - 显式分配

        - 重新均衡分片数据

            - 使用动态分配策略，当一个分片快满的时候可以设置一个标志告诉应用不要再放数据了

            - 为每个分片设置两台备库，然后使用归档工具来剔除不要的数据，可以不停机的分开两片数据

        - 生成全局唯一ID

            - 使用auto_increment_increment和auto_increment_offset - 一个奇数一个偶数一个增加1一个增加2

            - 全局节点中创建表 - 从一个全局的表里申请ID

            - 使用memcached的incr数据，使用redis来申请ID

            - 批量分配数字 - 从全局节点里批量申请ID 不够再获取

            - 使用复合值 - 分片ID+自增ID

            - 使用GUID - 不过不适合作为INNODB的主键

            - snowflake算法/美团leave

        - 分片工具

            - hibernate shards

            - shared-query

            - sphinx

5. 通过多实例扩展

    - 每个mysql实例绑定到单个CPU核心上

    - 在性能强悍的服务器上最好运行多个服务

6. 通过集群扩展

    - mysql cluster / NDB

    - clustrix

    - scalebase

    - geniedb

    - akiban

7. 向内扩展 - 归档一些很少或者从不使用的数据

    - 对应用的影响 - 逐步剔除 不要影响事务处理

    - 要归档的行 

    - 维护数据的一致性

    - 避免数据丢失

    - 解除归档

    - 保持活跃数据独立

        * 将表划分为几个部分

        * mysql分区

        * 基于时间的数据分区
负载均衡 

- 可扩展、高效性、可用性、透明性、一致性 （wackamole/dns/lvs/f5等hardware/tcp代理/mysql proxy/应用负载均衡）

1. 直接链接

    - 复制上的读写分离

        * 基于查询分离 - 能容忍脏数据的查询分到备库或者被动服务器上

        * 基于脏数据分离 - 应用检查复制延迟

        * 基于会话分离 - 如果用户自己做了更新那么标记成已经更新，这段时间的查询都指向主库而不是备库

        * 基于版本分离 - 使用版本号如果用户更新了自己的数据那么版本可以更新然后去主库查

        * 基于全局版本/会话分离 - 使用show master/slave status操作来检查是否已经更新到了备库

    - 修改应用的配置 - 修改配置来使用不同的机器处理不同的程序

    - 修改DNS名

    - 转移IP地址 pacemaker

2. 引入中间件

    - 负载均衡器 - 注意mysql的一些特定的点是否负载均衡支持

    - 负载均衡算法 - 随机/轮询/最少连接数/最快响应/哈希/权重

    - 在服务器池中添加或者删除服务器

3. 一主多备间的负载均衡

    - 功能分区 - 不同功能的备库

    - 过滤和数据分区 - 使用复制过滤的功能来分区

    - 将部分写操作转移到备库

    - 保证备库跟上主库

    - 同步写操作 - 确保一定写到了至少一个备库上才算成功 半同步复制